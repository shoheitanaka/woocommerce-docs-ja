---
sidebar_label: Guiding principles
sidebar_position: 0
---

# ストア API の指針 

Store APIでエンドポイントを拡張、作成、更新する際には、以下の原則を考慮する必要がある。

## ルートには[明確に定義されたJSONスキーマ](https://developer.wordpress.org/rest-api/extending-the-rest-api/schema/)を含めなければならない。

各ルート/エンドポイントは入力データの特定の構造を必要とし、定義された予測可能な構造を使用してデータを返すべきである。これはJSONスキーマで定義されており、APIが返すことができるすべてのプロパティと、どの入力パラメータを受け入れることができるかの包括的なリストを含んでいる。

よく定義されたスキーマは、APIへのリクエストを検証し、サニタイズすることを可能にするので、セキュリティのレイヤーも提供する。

スキーマを定義する際には、[JSONスキーマ標準](http://json-schema.org/)と同様に、利用可能なプロパティと型を文書化した[WordPress REST APIハンドブック](https://developer.wordpress.org/rest-api/extending-the-rest-api/schema/)に注意してください。これに加えて

* プロパティはsnake_case 🐍を使用する。
* 曖昧な用語は避け、プロパティ名は "WooCommerce "用語や設定名ではなく、理解しやすい言語を使用するようにしましょう。
* プロパティはアメリカ英語で定義されるべきですが、フィールドの説明はローカライズされるべきです。
* 例えば、値が該当しない場合、`null`型を使用します。
* `sanitize_callback`および`validate_callback`は、リクエストを処理する前にデータが正しい形式で受信されることを保証するために、可能な限り推奨されます。

一貫性のあるスキーマを定義するのに苦労しているなら、そのアプローチには欠陥があるかもしれません。よくある実例は、_Post Tags_のようなものを表現することです。レスポンスのプロパティフィールド名としてスラッグを使いたくなるかもしれません：

```php
tags: [
  "my-tag": {
    // ...tag data
  },
  "my-other-tag": {
    // ...tag data
  }
]
```

しかし、これはSchemaで表現するのが難しく、クライアントにとって予測不可能である。よりよいアプローチは、データの配列を使用し、そのプロパティの1つをスラッグとすることでしょう：

```php
tags: [
  {
    "slug": "my-tag",
    // ...tag data
  },
  {
    "slug": "my-other-tag",
    // ...tag data
  }
]
```

## ルートは単一のタイプのスキーマを持つリソースを中心に設計されるべきである

ルートは操作（動詞）ではなく、リソース（名詞）を中心に設計されるべきである。また、ルートはスキーマで定義された1種類のデータのみを返すべきです。例えば

| ルート | リソースタイプ | 期待されるデータ |
| ------------------------ | ------------- | --------------------------- |
| `wc/store/v1/cart` | Cart | カートオブジェクト |
| `wc/store/v1/cart/items` | Cart Item | カートアイテムオブジェクトのリスト |
| `wc/store/v1/products` | Product | 商品オブジェクトのリスト |
| `wc/store/v1/products/1` | Product | 商品オブジェクト |

Store APIには、このルールに2つの顕著な例外があります。

### エラー処理

検証エラーを含むエラーは、エラー・レスポンス・コード (4xx または 5xx) と [`WP_Error` オブジェクト](https://developer.wordpress.org/reference/classes/wp_error/) を返す必要があります。`AbstractRoute`クラスは、`WP_Error`オブジェクトを有効なJSONレスポンスに変換する処理を行います。

エラーメッセージはローカライズされるべきであるが、顧客向けの言語で書かれる必要はない（クライアントは、必要に応じて顧客向けの通知を作成するために指定されたエラーコードを使用する必要がある）。

エラーコードには接頭辞 `woocommerce_rest_` を付ける。

### カート操作

エンドポイントの中には、クライアントがAPIを何度も往復する必要がないように、操作に重点を置いて設計されているものもある。これは純粋に利便性のためである。

例えば、`wc/store/v1/cart/add-item`エンドポイントは、数量と商品IDを受け取りますが、更新された商品リストではなく、完全なカートオブジェクトを返します。

## 公開されるデータは現在のユーザーのものか、機密性のないものでなければならない

顧客データや注文データを含むリソースは、現在のセッションのみを反映する必要があります。プライバシーの侵害やセキュリティの問題になるので、他の顧客のデータを返さないでください。

設定などのストアデータ(例えば、ストア通貨)はレスポンスで許可されますが、_private or sensitive data_は避けなければなりません。データへのより広範なアクセスを許可するには、認証された[WC REST API](https://woocommerce.github.io/woocommerce-rest-api-docs/#introduction)を使用する必要があります。

APIから返されるデータは[__escape](https://developer.wordpress.org/themes/theme-security/data-sanitization-escaping/)されるべきではありませんが（これはレンダリングするクライアントに任されています）、サニタイズされるべきです。例えば、HTMLは[`wp_kses_post`](https://developer.wordpress.org/reference/functions/wp_kses_post/)を通して実行されるべきである。

APIから送られてくるデータを適切にエスケープするのはクライアントの責任だが、安全でない可能性のあるデータを返さないようにすべきだ。

## リソースのコレクションはページ分割されるべきである

大量のデータは、サーバーに負担をかけないようにページ分割されるべきである。例えば、商品のコレクションを返す場合。

* レスポンス・ヘッダ `X-WP-Total`、`X-WP-TotalPages`、`page`、`per_page` を使って、利用可能なリソースを示す。
* 特定のページを取得するには、パラメータ __INLINE_CODE_2__ と __INLINE_CODE_3__ を使用します。
* INLINE_CODE_4__の最大許容値は100です。

## API レスポンスには標準的な HTTP ステータスコードを使用する。

コンテンツを返すときは、次のような有効なHTTPレスポンスコードを使用してください：

* 成功したレスポンスには`200 OK`（これがデフォルトのレスポンスコードです）。
* リソースの作成時、例えば新しいカートアイテムの追加や新しいクーポンの適用には `201 Created` を使用します。
* 削除に成功した場合は`204 No Content`。
* 必須パラメータが設定されていない場合の`400 Bad Request`。
* INLINE_CODE_4__ リクエストが許可されない場合、例えば提供されたセキュリティnonceが無効な場合。
* リソースが存在しない場合。
* リソースが更新できない場合、`409 Conflict`。例えば、カートの中の何かが無効でリクエスト中に削除された場合など。

`DELETE`リクエストに関する注意点ですが、WordPress REST APIでは削除されたオブジェクトを返すのが一般的なパターンです。Store API の場合は、代わりにステータスコード `204 No Content` で空のレスポンスを返すようにしています。このほうが効率的です。

[HTTPステータスコードの完全なリストはこちら](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)

## Breaking changes should be avoided by possible

Store APIは、Schemaを使用することで、それ自身とAPIコンシューマーとの間の契約を確立する。この契約は、絶対に必要な場合を除き、破棄されるべきではない。もし破壊的な変更が必要であれば、Store APIの新しいバージョンをリリースする必要がある。

破壊的変更とは、既存のスキーマのフォーマットを変更するもの、スキーマのプロパティを削除するもの、既存のルートを削除するもの、あるいは、コンシューマがすでに使用しているかもしれないパブリックなものに対して後方互換性のない変更を加えるものです。大きな変更が必要な場合は、既存のプロパティを削除するのではなく[非推奨](http://json-schema.org/draft/2019-09/json-schema-validation.html#rfc.section.9.3)にしたり、[ルートを非推奨](https://datatracker.ietf.org/doc/html/rfc8594)にして別のルートに置き換えたりすることで、変更を避けることができます。

APIのバージョンを上げることなく、壊れることのない変更は常に許可される。これらの例には以下が含まれる：

* スキーマに新しいプロパティを追加する
* 新しいルート、エンドポイント、メソッドの追加
* オプションのリクエストパラメータを追加する
* レスポンス・フィールドの並び替え

バグの範囲が後方互換性のない変更を引き起こさない限り、バグ修正のためにバージョンが上がることはない。バックポートが必要なセキュリティ問題を除き、過去のAPIバージョンに修正がロールバックされることはない。
